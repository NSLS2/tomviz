{
    "operators": [
        {
            "argumentTypeInformation": {
                "threshold": "double"
            },
            "arguments": {
                "threshold": 5
            },
            "description": "",
            "id": "0x56251acc7eb0",
            "label": "Remove Bad Pixels",
            "script": "def transform(dataset, threshold=None):\n    \"\"\"Remove bad pixels in tilt series.\"\"\"\n\n    import scipy.ndimage\n    import numpy as np\n\n    tiltSeries = dataset.active_scalars.astype(np.float32)\n\n    for i in range(tiltSeries.shape[2]):\n        I = tiltSeries[:, :, i]\n        I_pad = np.lib.pad(I, (1, 1), 'edge')\n\n        # calculate standard deviation in a 3 x 3 window\n        averageI2 = scipy.ndimage.filters.uniform_filter(I_pad ** 2)\n        averageI = scipy.ndimage.filters.uniform_filter(I_pad)\n        std = np.sqrt(abs(averageI2 - averageI**2))[1:-1, 1:-1]\n\n        medianI = scipy.ndimage.filters.median_filter(I_pad, 2)[1:-1, 1:-1]\n\n        #identify bad pixels\n        badPixelsMask = abs(I - medianI) > std * threshold\n\n        I[badPixelsMask] = medianI[badPixelsMask]\n        tiltSeries[:, :, i] = I\n\n    # Set the result as the new scalars.\n    dataset.active_scalars = tiltSeries\n",
            "type": "Python"
        },
        {
            "id": "0x7f3e04014550",
            "offsets": [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ],
            "type": "TranslateAlign"
        },
        {
            "arguments": {
                "SHIFT": [
                    0,
                    0,
                    0
                ],
                "rotation_angle": 0,
                "tilt_axis": 0
            },
            "description": "{\n  \"name\" : \"RotationAlign\",\n  \"label\" : \"Rotation Alignment\",\n  \"description\" : \"Align the rotation axis of a tilt series to the x-axis.\",\n  \"widget\" : \"RotationAlignWidget\",\n  \"parameters\" : [\n    {\n      \"name\" : \"SHIFT\",\n      \"label\" : \"Shift\",\n      \"description\" : \"Amount to shift by.\",\n      \"type\" : \"double\",\n      \"default\" : [0.0, 0.0, 0.0]\n    },\n    {\n      \"name\" : \"rotation_angle\",\n      \"label\" : \"Angle\",\n      \"description\" : \"Rotation angle in degrees.\",\n      \"type\" : \"double\",\n      \"default\" : 90.0,\n      \"minimum\" : -360.0,\n      \"maximum\" : 360.0\n    },\n    {\n      \"name\" : \"tilt_axis\",\n      \"label\" : \"Tilt Axis\",\n      \"description\" : \"The tilt axis (0 for X, 1 for Y).\",\n      \"type\" : \"int\",\n      \"default\" : 0,\n      \"minimum\" : 0,\n      \"maximum\" : 1\n    }\n  ],\n  \"help\" : {\n    \"url\" : \"alignment/#tilt-axis-alignment\"\n  }\n}\n\n\n",
            "help": {
            },
            "id": "0x56251ce96340",
            "label": "Tilt Axis Alignment (manual)",
            "script": "# Perform alignment to the estimated rotation axis\n#\n# Developed as part of the tomviz project (www.tomviz.com).\n\n\ndef transform(dataset, SHIFT=None, rotation_angle=90.0, tilt_axis=0):\n    from tomviz import utils\n    from scipy import ndimage\n    import numpy as np\n\n    data_py = dataset.active_scalars # Get data as numpy array.\n\n    if data_py is None: #Check if data exists\n        raise RuntimeError(\"No data array found!\")\n    if SHIFT is None:\n        SHIFT = np.zeros(len(data_py.shape), dtype=np.int)\n    data_py_return = np.empty_like(data_py)\n    ndimage.interpolation.shift(data_py, SHIFT, order=0, output=data_py_return)\n\n    rotation_axis = 2 # This operator always assumes the rotation axis is Z\n    if rotation_angle == []: # If tilt angle not given, assign it to 90 degrees.\n        rotation_angle = 90\n\n    axis1 = (rotation_axis + 1) % 3\n    axis2 = (rotation_axis + 2) % 3\n    axes = (axis1, axis2)\n    shape = utils.rotate_shape(data_py_return, rotation_angle, axes=axes)\n    data_py_return2 = np.empty(shape, data_py_return.dtype, order='F')\n    ndimage.interpolation.rotate(\n        data_py_return, rotation_angle, output=data_py_return2, axes=axes)\n\n    dataset.active_scalars = data_py_return2\n",
            "type": "Python"
        },
        {
            "arguments": {
                "Nrecon": 256,
                "Nupdates": 0,
                "filter": 1,
                "interp": 0
            },
            "dataSources": [
                {
                    "modules": [
                        {
                            "activeScalars": -1,
                            "id": "0x56251c3fc510",
                            "properties": {
                                "gridColor": [
                                    0.8,
                                    0.8,
                                    0.8
                                ],
                                "gridLines": false,
                                "gridVisibility": false,
                                "visibility": true
                            },
                            "type": "Outline",
                            "viewId": 4235
                        },
                        {
                            "activeScalars": -1,
                            "id": "0x56251aa526f0",
                            "properties": {
                                "blendingMode": 0,
                                "interpolation": 1,
                                "lighting": {
                                    "ambient": 0,
                                    "diffuse": 1,
                                    "enabled": false,
                                    "specular": 1,
                                    "specularPower": 100
                                },
                                "rayJittering": true,
                                "transferMode": 0,
                                "visibility": true
                            },
                            "type": "Volume",
                            "useDetachedColorMap": false,
                            "viewId": 4235
                        }
                    ]
                }
            ],
            "description": "{\n  \"name\" : \"ReconstructWBP\",\n  \"label\" : \"Weighted Back Projection\",\n  \"description\" : \"Reconstruct a tilt series using Weighted Back Projection (WBP) method. The tilt axis must be parallel to the x-direction and centered in the y-direction. The size of reconstruction will be (Nx,N,N), where Nx is the number of pixels in x-direction and N can be specified below. The maximum N allowed is 4096. Reconstrucing a 512x512x512 tomogram typically takes 7-10 mins.\",\n  \"children\": [\n    {\n      \"name\": \"reconstruction\",\n      \"label\": \"Reconstruction\",\n      \"type\": \"reconstruction\"\n    }\n  ],\n  \"parameters\" : [\n    {\n      \"name\" : \"Nrecon\",\n      \"label\" : \"Reconstruction Size\",\n      \"type\" : \"int\",\n      \"data-default\" : \"num-voxels-y\",\n      \"minimum\" : 1,\n      \"maximum\" : 4096\n    },\n    {\n      \"name\" : \"filter\",\n      \"label\" : \"Fourier Weighting Filter\",\n      \"type\" : \"enumeration\",\n      \"default\" : 1,\n      \"options\" : [\n        {\"None\" : 0},\n        {\"Ramp\" : 1},\n        {\"Shepp-Logan\" : 2},\n        {\"Cosine\" : 3},\n        {\"Hamming\" : 4},\n        {\"Hann\" : 5}\n      ]\n    },\n    {\n      \"name\" : \"interp\",\n      \"label\" : \"Back Projection Interpolation Method\",\n      \"type\" : \"enumeration\",\n      \"default\" : 0,\n      \"options\" : [\n        {\"Linear\" : 0},\n        {\"Nearest\" : 1},\n        {\"Spline\" : 2},\n        {\"Cubic\" : 3}\n      ]\n    },\n    {\n      \"name\" : \"Nupdates\",\n      \"label\" : \"Number Of Updates During Live Reconstruction\",\n      \"type\" : \"int\",\n      \"default\" : 0,\n      \"minimum\" : 0\n    }\n  ],\n  \"help\" : {\n    \"url\": \"reconstruction/#weighted-back-projection\"\n  }\n}\n",
            "help": {
            },
            "id": "0x56251c442b20",
            "label": "Reconstruct (Back Projection)",
            "script": "import numpy as np\nfrom scipy.interpolate import interp1d\nimport tomviz.operators\nimport time\n\n\nclass ReconWBPOperator(tomviz.operators.CancelableOperator):\n\n    def transform(self, dataset, Nrecon=None, filter=None, interp=None,\n                  Nupdates=None):\n        \"\"\"\n        3D Reconstruct from a tilt series using Weighted Back-projection Method\n        \"\"\"\n        self.progress.maximum = 1\n\n        interpolation_methods = ('linear', 'nearest', 'spline', 'cubic')\n        filter_methods = ('none', 'ramp', 'shepp-logan',\n                          'cosine', 'hamming', 'hann')\n\n        # Get Tilt angles\n        tilt_angles = dataset.tilt_angles\n        tiltSeries = dataset.active_scalars\n        if tiltSeries is None:\n            raise RuntimeError(\"No scalars found!\")\n\n        Nslice = tiltSeries.shape[0]\n\n        self.progress.maximum = Nslice\n        step = 0\n\n        recon = np.empty([Nslice, Nrecon, Nrecon], dtype=np.float32, order='F')\n        t0 = time.time()\n        counter = 1\n        etcMessage = 'Estimated time to complete: n/a'\n\n        child = dataset.create_child_dataset() #create child for recon\n\n        for i in range(Nslice):\n            if self.canceled:\n                return\n            self.progress.message = 'Slice No.%d/%d. ' % (\n                i + 1, Nslice) + etcMessage\n\n            recon[i, :, :] = wbp2(tiltSeries[i, :, :], tilt_angles, Nrecon,\n                                  filter_methods[filter],\n                                  interpolation_methods[interp])\n            step += 1\n            self.progress.value = step\n            timeLeft = (time.time() - t0) / counter * (Nslice - counter)\n            counter += 1\n            timeLeftMin, timeLeftSec = divmod(timeLeft, 60)\n            timeLeftHour, timeLeftMin = divmod(timeLeftMin, 60)\n            etcMessage = 'Estimated time to complete: %02d:%02d:%02d' % (\n                timeLeftHour, timeLeftMin, timeLeftSec)\n\n            # Update only once every so many steps\n            if Nupdates != 0 and (i + 1) % (Nslice//Nupdates) == 0:\n                child.active_scalars = recon #add recon to child\n                # This copies data to the main thread\n                self.progress.data = child\n\n        # One last update of the child data.\n        child.active_scalars = recon #add recon to child\n        self.progress.data = child\n\n        returnValues = {}\n        returnValues[\"reconstruction\"] = child\n        return returnValues\n\n\ndef wbp2(sinogram, angles, N=None, filter=\"ramp\", interp=\"linear\"):\n    if sinogram.ndim != 2:\n        raise ValueError('Sinogram must be 2D')\n    (Nray, Nproj) = sinogram.shape\n    if Nproj != angles.size:\n        raise ValueError('Sinogram does not match angles!')\n\n    interpolation_methods = ('linear', 'nearest', 'spline', 'cubic')\n    if interp not in interpolation_methods:\n        raise ValueError(\"Unknown interpolation: %s\" % interp)\n    if not N:  # if output size is not given\n        N = int(np.floor(np.sqrt(Nray**2 / 2.0)))\n\n    ang = np.double(angles) * np.pi / 180.0\n    # Create Fourier filter\n    F = makeFilter(Nray, filter)\n    # Pad sinogram for filtering\n    s = np.lib.pad(sinogram, ((0, F.size - Nray), (0, 0)),\n                   'constant', constant_values=(0, 0))\n    # Apply Fourier filter\n    s = np.fft.fft(s, axis=0) * F\n    s = np.real(np.fft.ifft(s, axis=0))\n    # Change back to original\n    s = s[:Nray, :]\n\n    # Back projection\n    recon = np.zeros((N, N), np.float32)\n    center_proj = Nray // 2  # Index of center of projection\n    [X, Y] = np.mgrid[0:N, 0:N]\n    xpr = X - int(N) // 2\n    ypr = Y - int(N) // 2\n\n    for j in range(Nproj):\n        t = ypr * np.cos(ang[j]) - xpr * np.sin(ang[j])\n        x = np.arange(Nray) - center_proj\n        if interp == 'linear':\n            bp = np.interp(t, x, s[:, j], left=0, right=0)\n        elif interp == 'spline':\n            interpolant = interp1d(\n                x, s[:, j], kind='slinear', bounds_error=False, fill_value=0)\n            bp = interpolant(t)\n        else:\n            interpolant = interp1d(\n                x, s[:, j], kind=interp, bounds_error=False, fill_value=0)\n            bp = interpolant(t)\n        recon = recon + bp\n\n    # Normalize\n    recon = recon * np.pi / 2 / Nproj\n    return recon\n\n# Filter (1D) projections.\n\n\ndef makeFilter(Nray, filterMethod=\"ramp\"):\n    # Calculate next power of 2\n    N2 = 2**np.ceil(np.log2(Nray))\n    # Make a ramp filter.\n    freq = np.fft.fftfreq(int(N2)).reshape(-1, 1)\n    omega = 2 * np.pi * freq\n    filter = 2 * np.abs(freq)\n\n    if filterMethod == \"ramp\":\n        pass\n    elif filterMethod == \"shepp-logan\":\n        filter[1:] = filter[1:] * np.sin(omega[1:]) / omega[1:]\n    elif filterMethod == \"cosine\":\n        filter[1:] = filter[1:] * np.cos(filter[1:])\n    elif filterMethod == \"hamming\":\n        filter[1:] = filter[1:] * (0.54 + 0.46 * np.cos(omega[1:] / 2))\n    elif filterMethod == \"hann\":\n        filter[1:] = filter[1:] * (1 + np.cos(omega[1:] / 2)) / 2\n    elif filterMethod == \"none\":\n        filter[:] = 1\n    else:\n        raise ValueError(\"Unknown filter: %s\" % filterMethod)\n\n    return filter\n",
            "type": "Python"
        }
    ]
}
